# Linux中Pam模块

## pam简介

`Linux-PAM`(Linux可插入认证模块)是一套共享库，使本地系统管理员可以随意选择程序的认证方式。换句话说，不用重新编译一个包含`PAM`模块功能的应用程序，就可以改变它使用的认证机制。这种方式下，就算升级本地认证机制，也不用修改程序。`PAM`使用配置`/etc/pam.d/`下的文件，来管理对程序的认证方式。应用程序调用相应的配置文件，从而调用本地的认证模块。

认证模块放置在`/lib/security`目录下，以加载库的形式存在。

像我们使用`su`命令时，系统会提示输入`root`用户密码，这就是`su`命令通过调用`PAM`模块实现的。

![image-20210611153222171](https://raw.githubusercontent.com/supermanc88/ImageSources/master/20210611173939.png)



## pam的配置文件

以`sshd`为例：

![image-20210611153412163](https://raw.githubusercontent.com/supermanc88/ImageSources/master/20210611173954.png)



### PAM模块类型

PAM模块有四种类型，分别代表四种不同的任务：

- 认证管理(`auth`)：认证模块接口，如验证用户身份、检查密码是否可以通过，并设置用户凭据
- 账号管理(`account`)：账户模块接口，检查指定账户是否满足当前验证条件，如用户是否有权限访问所请求的服务，检查账户是否到期
- 会话管理(`session`)：会话模块接口，用于管理和配置用户会话。会话在用户成功认证之后启动生效
- 密码管理(`password`)：密码模块接口，用于更改用户密码，以及强制使用强密码配置

一个类型可能有多行，它们按顺序依次由PAM模块调用。

单个`PAM`库模块可以提供给任何或所有模块接口使用。例如，`pam_unix.so`提供给四个模块接口使用。



### PAM控制标志

所有的PAM模块被调用时都会返回成功或者失败的结果，每个PAM模块中由多个对应的`控制标志`决定结果是否对过或失败。每一个控制标志对应一个处理结果，**PAM库将这些成功[或失败]的结果整合为一个整体的成功[或失败]结果**，然后将结果返回给应用程序。模块可以按特定的顺序堆叠。`控制标志`是实现用户在对某一个特定的应用程序或服务身份验证的具体实现细节。该控制标志是PAM配置文件中的第二个字段，`PAM`控制标志如下：

![img](https://raw.githubusercontent.com/supermanc88/ImageSources/master/20210611174002.png)

- `required`   **表示该行以及所涉及模块的成功是用户通过鉴别的必要条件。换句话说，只有当对应于应用程序的所有带 required标记的模块全部成功后，该程序才能通过鉴别。**同时，如果任何带required标记的模块出现了错误，PAM并不立刻将错误消息返回给应用程序，而是在所有模块都调用完毕后才将错误消息返回调用他的程序。 反正说白了，就是**必须将所有的模块都执行一次，其中任何一个模块验证出错，验证都会继续进行，并在执行完成之后才返回错误信息。这样做的目的就是不让用户知道自己被哪个模块拒绝，通过一种隐蔽的方式来保护系统服务。**就像设置防火墙规则的时候将拒绝类的规则都设置为drop一样，以致于用户在访问网络不成功的时候无法准确判断到底是被拒绝还是目标网络不可达。
- `requisite`   模块结果必须**成功才能继续认证**，如果在此处测试**失败，则会立即将失败结果通知给用户**。
- `sufficient`    模块结果如果**测试失败，将被忽略**。如果`sufficient`模块测试成功，并且之前的`required`模块没有发生故障，`PAM`会向应用程序返回通过的结果，不会再调用堆栈中其他模块。表示该行以及所涉及模块验证成功是用户通过鉴别的充分条件。也就是说**只要标记为`sufficient`的模块一旦验证成功，那么`PAM`便立即向应用程序返回成功结果而不必尝试任何其他模块**。即便后面的层叠模块使用了`requisite`或者`required`控制标志也是一样。**当标记为sufficient的模块失败时，sufficient模块会当做 optional对待。因此拥有sufficient 标志位的配置项在执行验证出错的时候并不会导致整个验证失败，但执行验证成功之时则大门敞开。所以该控制位的使用务必慎重。**
- `optional`    该模块返回的通过/失败**结果被忽略**。**当没有其他模块被引用时，标记为optional模块并且成功验证时该模块才是必须的**。该模块被调用来执行一些操作，并不影响模块堆栈的结果。表示即便该行所涉及的模块验证失败用户仍能通过认证。在`PAM`体系中，带有该标记的模块失败后将继续处理下一模块。也就是说即使本行指定的模块验证失败，也允许用户享受应用程序提供的服务。使用该标志，`PAM`框架会忽略这个模块产生的验证错误，继续顺序执行下一个层叠模块。
- `include`	  与其他控制标志不同，**include与模块结果的处理方式无关**。该标志用于直接引用其他`PAM`模块的配置参数。表示在验证过程中调用其他的PAM配置文件。在`RHEL`系统中有相当多的应用通过完整调用`/etc/pam.d/system-auth`来实现认证而不需要重新逐一去写配置项。这也就意味着在很多时候只要用户能够登录系统，针对绝大多数的应用程序也能同时通过认证。

另外还有一种比较复杂的格式为`value = action`的语法来设置控制标志，标志之间会以空格分开。格式如下：

```shell
value1 = action1 value2 = action2 ……
```

其中value可以是下列Linux PAM库的返回值：
`success`、`open_err`、`symbol_err`、`service_err`、 `system_err`、`buf_err`、`perm_denied`、`auth_err`、`cred_insufficient`、`authinfo_unavail`、`user_unknown`、`maxtries`、`new_authtok_reqd`、`acct_expired`、 `session_err`、`cred_unavail`、`cred_expired`、`cred_err`、`no_module_data`、`conv_err`、 `authtok_err`、`authtok_recover_err`、`authtok_lock_busy`、`authtok_disable_aging`、 `try_again`、`ignore`、`abort`、`authtok_expired`、`module_unknown`、`bad_item`和`default`。

最后一个(`default`)能够用来设置上面的返回值无法表达的行为。

actionN可以是一个非负整数或者是下面的记号之一：`ignore`、`ok`、`done`、`bad`、`die`和`reset`。如果是非负整数J，就表示需要忽略后面J个同样类型的模块。通过这种方式，系统管理者可以更加灵活地设置层叠模块，模块的层叠路径由单个模块的反应决定。

**关于这几个记号的详细解释：**

- `ignore`：如果使用层叠模块，那么这个模块的返回值将被忽略，不会被应用程序知道。
- `bad`：他表示这个返回码应该被看作是模块验证失败的标志。如果这个模块是层叠模块的第一个验证失败的模块，那么他的状态值就是整个层叠模块验证的状态值和结果。
- `die`：终止层叠模块验证过程，立刻返回到应用程序。
- `ok`：告诉PAM这个模块的**返回值将直接作为所有层叠模块的返回值**。也就是说，如果这个模块前面的模块返回状态是`PAM_SUCCESS`，那这个返回值就会覆盖前面的返回状态。注意：如果前面的模块的返回状态表示模块验证失败，那么不能使用这个返回值再加以覆盖。
- `done`：终止后续层叠模块的验证，把控制权立刻交回应用程序。
- `reset`：清除所有层叠模块的返回状态，从下一个层叠模块重新开始验证。



### PAM模块路径

模块路径.即要调用模块的位置. 如果是64位系统，一般保存在/lib64/security,如: pam_unix.so，同一个模块,可以出现在不同的类型中.它在不同的类型中所执行的操作都不相同.这是由于每个模块，针对不同的模块类型,编制了不同的执行函数。



### PAM模块参数

模块参数,即传递给模块的参数.参数可以有多个,之间用空格分隔开,如:`password required pam_unix.so nullok obscure min=4 max=8 md5`。



### PAM配置方法

可以使用 `man` 命令查看配置，比如要查找某个程序支持PAM模块的配置，可以使用 `man` 加模块名(去掉.so)查找说明。

如 `man pam_unix`。(模块名可以在目录`/lib/security/`或`/lib64/security/`中找到。)



### 例子

环境：CentOS7 1708

`/etc/pam.d/system-auth-ac`

![image-20210611172650862](https://raw.githubusercontent.com/supermanc88/ImageSources/master/20210611174009.png)



第一部分表示，当用户登录的时候，首先会通过auth类接口对用户身份进行识别和密码认证。所以在该过程中验证会经过几个带auth的配置项。

其中的第一步是通过`pam_env.so`模块来定义用户登录之后的环境变量， pam_env.so允许设置和更改用户登录时候的环境变量，默认情况下，若没有特别指定配置文件，将依据`/etc/security/pam_env.conf`进行用户登录之后环境变量的设置。

然后通过pam_unix.so模块来提示用户输入密码，并将用户密码与/etc/shadow中记录的密码信息进行对比，如果密码比对结果正确则允许用户登录，而且该配置项的使用的是“sufficient”控制位，即表示只要该配置项的验证通过，用户即可完全通过认证而不用再去走下面的认证项。不过在特殊情况下，用户允许使用空密码登录系统，例如当将某个用户在/etc/shadow中的密码字段删除之后，该用户可以只输入用户名直接登录系统。

下面的配置项中，通过pam_succeed_if.so对用户的登录条件做一些限制，表示允许uid大于500的用户在通过密码验证的情况下登录，在Linux系统中，一般系统用户的uid都在500之内，所以该项即表示允许使用useradd命令以及默认选项建立的普通用户直接由本地控制台登录系统。

最后通过pam_deny.so模块对所有不满足上述任意条件的登录请求直接拒绝，pam_deny.so是一个特殊的模块，该模块返回值永远为否，类似于大多数安全机制的配置准则，在所有认证规则走完之后，对不匹配任何规则的请求直接拒绝。



第二部分的三个配置项主要表示通过account账户类接口来识别账户的合法性以及登录权限。

第一行仍然使用pam_unix.so模块来声明用户需要通过密码认证。第二行承认了系统中uid小于500的系统用户的合法性。之后对所有类型的用户登录请求都开放控制台。



第三部分会通过password口另类接口来确认用户使用的密码或者口令的合法性。第一行配置项表示需要的情况下将调用pam_cracklib来验证用户密码复杂度。如果用户输入密码不满足复杂度要求或者密码错，最多将在三次这种错误之后直接返回密码错误的提示，否则期间任何一次正确的密码验证都允许登录。需要指出的是，pam_cracklib.so是一个常用的控制密码复杂度的pam模块，关于其用法举例我们会在之后详细介绍。之后带pam_unix.so和pam_deny.so的两行配置项的意思与之前类似。都表示需要通过密码认证并对不符合上述任何配置项要求的登录请求直接予以拒绝。不过用户如果执行的操作是单纯的登录，则这部分配置是不起作用的。



第四部分主要将通过session会话类接口为用户初始化会话连接。其中几个比较重要的地方包括，使用pam_keyinit.so表示当用户登录的时候为其建立相应的密钥环，并在用户登出的时候予以撤销。不过该行配置的控制位使用的是optional，表示这并非必要条件。之后通过pam_limits.so限制用户登录时的会话连接资源，相关pam_limit.so配置文件是/etc/security/limits.conf，默认情况下对每个登录用户都没有限制。关于该模块的配置方法在后面也会详细介绍。



### 常用PAM模块介绍

| PAM模块          | 管理类型                         | 说明                                                         |
| ---------------- | -------------------------------- | ------------------------------------------------------------ |
| pam_unix.so      | auth                             | 提示用户输入密码,并与/etc/shadow文件相比对.匹配返回0         |
| pam_unix.so      | account                          | 检查用户的账号信息(包括是否过期等).帐号可用时,返回0.         |
| pam_unix.so      | password                         | 修改用户的密码. 将用户输入的密码,作为用户的新密码更新shadow文件 |
| pam_shells.so    | auth，account                    | 如果用户想登录系统，那么它的shell必须是在/etc/shells文件中   |
| pam_deny.so      | account，auth，password，session | 该模块可用于拒绝访问                                         |
| pam_deny.so      | account，auth，password，session | 模块任何时候都返回成功                                       |
| pam_securetty.so | auth                             | 如果用户要以root登录时,则登录的tty必须在/etc/securetty之中   |
| pam_listfile.so  | account，auth，password，session | 访问应用程的控制开关                                         |
| pam_cracklib.so  | password                         | 这个模块可以插入到一个程序的密码栈中,用于检查密码的强度      |
| pam_limits.so    | session                          | 定义使用系统资源的上限，root用户也会受此限制，可以通过/etc/security/limits.conf或/etc/security/limits.d/*.conf来设定 |



  

